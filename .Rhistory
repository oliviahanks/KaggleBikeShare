#plot prior
plot(mux, dnorm(mux, mt, sqrt(vt)), type = 'l', lwd = 3, col = 'red', ylab = 'Density', xlab = 'Treatment Mu', main = 'Prior and Posterior for Mu', ylim = c(0, 1))
#plot posterior
lines(mux, dnorm(mux, mean(treatmentPost[keep, 1]), sd(treatmentPost[keep, 1])), type = 'l', lwd = 3, col = 'blue')
#legend
legend('topright', legend = c('Prior', 'Posterior'), fill = c('red', 'blue'))
# Treatment sigma^2
#plot prior
plot(sigmax, dinvgamma(sigmax, at, rate = bt), type = 'l', lwd = 3, col = 'red', ylab = 'Density', xlab = 'Cholesterol for Urban Guatamala', main = 'Prior and Posterior for mu')
# Control mu
mux <- seq(0, 100, length = 10000)
#plot prior
plot(mux, dnorm(mux, mc, sqrt(vc)), type = 'l', lwd = 3, col = 'red', ylab = 'Density', xlab = 'Control Mu', main = 'Prior and Posterior for Mu', ylim = c(0, 1))
#plot posterior
lines(mux, dnorm(mux, mean(controlPost[keep, 1]), sd(controlPost[keep, 1])), type = 'l', lwd = 3, col = 'blue')
#legend
legend('topright', legend = c('Prior', 'Posterior'), fill = c('red', 'blue'))
# Control sigma^2
sigmax <- seq(0, 100, length = 10000)
#plot posterior
hist(controlPost[keep, 2], probability = TRUE, col = 'blue')
#plot prior
lines(sigmax, dinvgamma(sigmax, ac, rate = bc), type = 'l', lwd = 3, col = 'red', ylab = 'Density', xlab = 'Control sigma^2', main = 'Prior and Posterior for sigma^2')
#legend
legend('topright', legend = c('Prior', 'Posterior'), fill = c('red', 'blue'))
# Treatment mu
#plot prior
plot(mux, dnorm(mux, mt, sqrt(vt)), type = 'l', lwd = 3, col = 'red', ylab = 'Density', xlab = 'Treatment Mu', main = 'Prior and Posterior for Mu', ylim = c(0, 1))
#plot posterior
lines(mux, dnorm(mux, mean(treatmentPost[keep, 1]), sd(treatmentPost[keep, 1])), type = 'l', lwd = 3, col = 'blue')
#legend
legend('topright', legend = c('Prior', 'Posterior'), fill = c('red', 'blue'))
# Treatment sigma^2
#plot posterior
hist(treatmentPost[keep, 2], probability = TRUE, col = 'blue')
#plot prior
lines(sigmax, dinvgamma(sigmax, at, rate = bt), type = 'l', lwd = 3, col = 'red', ylab = 'Density', xlab = 'Treatment sigma^2', main = 'Prior and Posterior for sigma^2')
#legend
legend('topright', legend = c('Prior', 'Posterior'), fill = c('red', 'blue'))
par(mfrow=c(2,2))
# Control mu
mux <- seq(0, 100, length = 10000)
#plot prior
plot(mux, dnorm(mux, mc, sqrt(vc)), type = 'l', lwd = 3, col = 'red', ylab = 'Density', xlab = 'Control Mu', main = 'Prior and Posterior for Mu', ylim = c(0, 1))
#plot posterior
lines(mux, dnorm(mux, mean(controlPost[keep, 1]), sd(controlPost[keep, 1])), type = 'l', lwd = 3, col = 'blue')
#legend
legend('topright', legend = c('Prior', 'Posterior'), fill = c('red', 'blue'))
# Control sigma^2
sigmax <- seq(0, 100, length = 10000)
#plot posterior
hist(controlPost[keep, 2], probability = TRUE, col = 'blue')
#plot prior
lines(sigmax, dinvgamma(sigmax, ac, rate = bc), type = 'l', lwd = 3, col = 'red', ylab = 'Density', xlab = 'Control sigma^2', main = 'Prior and Posterior for sigma^2')
#legend
legend('topright', legend = c('Prior', 'Posterior'), fill = c('red', 'blue'))
# Treatment mu
#plot prior
plot(mux, dnorm(mux, mt, sqrt(vt)), type = 'l', lwd = 3, col = 'red', ylab = 'Density', xlab = 'Treatment Mu', main = 'Prior and Posterior for Mu', ylim = c(0, 1))
#plot posterior
lines(mux, dnorm(mux, mean(treatmentPost[keep, 1]), sd(treatmentPost[keep, 1])), type = 'l', lwd = 3, col = 'blue')
#legend
legend('topright', legend = c('Prior', 'Posterior'), fill = c('red', 'blue'))
# Treatment sigma^2
#plot posterior
hist(treatmentPost[keep, 2], probability = TRUE, col = 'blue')
#plot prior
lines(sigmax, dinvgamma(sigmax, at, rate = bt), type = 'l', lwd = 3, col = 'red', ylab = 'Density', xlab = 'Treatment sigma^2', main = 'Prior and Posterior for sigma^2')
#legend
legend('topright', legend = c('Prior', 'Posterior'), fill = c('red', 'blue'))
par(mfrow=c(2,2))
# Control mu
mux <- seq(0, 100, length = 10000)
#plot prior
plot(mux, dnorm(mux, mc, sqrt(vc)), type = 'l', lwd = 3, col = 'red', ylab = 'Density', xlab = 'Control Mu', main = 'Prior and Posterior for Mu', ylim = c(0, 1))
#plot posterior
lines(mux, dnorm(mux, mean(controlPost[keep, 1]), sd(controlPost[keep, 1])), type = 'l', lwd = 3, col = 'blue')
#legend
legend('topright', legend = c('Prior', 'Posterior'), fill = c('red', 'blue'))
# Control sigma^2
sigmax <- seq(0, 100, length = 10000)
#plot posterior
hist(controlPost[keep, 2], probability = TRUE, col = 'blue')
#plot prior
lines(sigmax, dinvgamma(sigmax, ac, rate = bc), type = 'l', lwd = 3, col = 'red', ylab = 'Density', xlab = 'Control sigma^2', main = 'Prior and Posterior for sigma^2')
#legend
legend('topright', legend = c('Prior', 'Posterior'), fill = c('red', 'blue'))
# Treatment mu
#plot prior
plot(mux, dnorm(mux, mt, sqrt(vt)), type = 'l', lwd = 3, col = 'red', ylab = 'Density', xlab = 'Treatment Mu', main = 'Prior and Posterior for Mu', ylim = c(0, 1))
#plot posterior
lines(mux, dnorm(mux, mean(treatmentPost[keep, 1]), sd(treatmentPost[keep, 1])), type = 'l', lwd = 3, col = 'blue')
#legend
legend('topright', legend = c('Prior', 'Posterior'), fill = c('red', 'blue'))
# Treatment sigma^2
#plot posterior
hist(treatmentPost[keep, 2], probability = TRUE, col = 'blue')
#plot prior
lines(sigmax, dinvgamma(sigmax, at, rate = bt), type = 'l', lwd = 3, col = 'red', ylab = 'Density', xlab = 'Treatment sigma^2', main = 'Prior and Posterior for sigma^2')
#legend
legend('topright', legend = c('Prior', 'Posterior'), fill = c('red', 'blue'))
library(invgamma)
library(MASS)
control <- c(35.25,43.21, 47.63, 48.99, 32.34, 34.69, 34.39,
36.58, 33.85, 32.26, 36.71, 35.01, 38.42, 39.98, 40.04)
tmt <- c(35.40, 44.79, 51.10, 50.66, 31.25, 38.80, 39.65, 38.49,
34.97, 32.24, 34.18, 33.46, 44.45, 42.86, 39.11)
mt <- 40
vt <- 10^2
mc <- 35
vc <- 10^2
at <- 1
bt <- 1
ac <- 1
bc <- 1
J <- 100000
treatmentPost <- nnig.mcmc(data=tmt,m=mt,v=vt,a=at,b=bt,J=J)
controlPost <- nnig.mcmc(data=control,m=mc,v=vc,a=ac,b=bc,J=J)
# thinning
keep <- seq(11, J, length = 10000)
par(mfrow=c(2,2))
# Check convergence for Treatment Group
plot(treatmentPost[keep,1], type='l')
plot(treatmentPost[keep,2], type='l')
# Check convergence for Control Group
plot(controlPost[,1], type='l')
plot(controlPost[,2], type='l')
# Check mixing for Treatment Group
acf(treatmentPost[keep,1]) # mu
acf(treatmentPost[keep,2]) # sigma2
# mixing for the objective prior
acf(controlPost[keep,1]) # mu
acf(controlPost[keep,2]) # sigma2
hist(controlPost[keep,1]-treatmentPost[keep,1])
quantile(controlPost[keep,1]-treatmentPost[keep,1], c(0.025, 0.975))
quantile(controlPost[keep,2]/treatmentPost[keep,2], c(0.025, 0.975))
hist(controlPost[keep,1]-treatmentPost[keep,1], main = 'Histogram of Control mu - Treatment mu)
quantile(controlPost[keep,1]-treatmentPost[keep,1], c(0.025, 0.975))
quantile(controlPost[keep,2]/treatmentPost[keep,2], c(0.025, 0.975))
hist(controlPost[keep,1]-treatmentPost[keep,1], main = 'Histogram of Control mu - Treatment mu')
quantile(controlPost[keep,1]-treatmentPost[keep,1], c(0.025, 0.975))
quantile(controlPost[keep,2]/treatmentPost[keep,2], c(0.025, 0.975))
md <- 0
vd <- 10
controlMinusTmt <- control - tmt
nd <- nrow(controlMinusTmt)
ybard <- mean(controlMinusTmt)
sigma2d <- 7
mstard <- (nd*ybard*vd + md*sigma2d)/(nd*vd + sigma2d)
vstard <- (vd*sigma2d)/(nd*vd + sigma2d)
qnorm(c(0.025, 0.975), mean = mstard, sd = sqrt(vstard))
mstard
controlMinusTmt
nrow(controlMinusTmt)
md <- 0
vd <- 10
controlMinusTmt <- control - tmt
nd <- length(controlMinusTmt)
ybard <- mean(controlMinusTmt)
sigma2d <- 7
mstard <- (nd*ybard*vd + md*sigma2d)/(nd*vd + sigma2d)
vstard <- (vd*sigma2d)/(nd*vd + sigma2d)
qnorm(c(0.025, 0.975), mean = mstard, sd = sqrt(vstard))
bmi <- Pima.tr$bmi
bp <- Pima.tr$bp
# prior values
m0 <- 0; v0 <- 100^2
m1 <- 0; v1 <- 100^2
a <- 1; b <- 1
# vectors to hold MCMC samples
beta0 <- beta1 <- sigma2 <- numeric()
# Initial values.  This can be pretty much anything that is reasonable,
# but I am going to use the OLS estimates as starting values
lm1 <- lm(bp ~ bmi)
beta0[1] <- lm1$coefficients[1]
beta1[1] <- lm1$coefficients[2]
sigma2[1] <- summary(lm1)$sigma^2
# The number of MCMC iterations
J <- 100000
n <- length(bp)
for(j in 2:J){
# update beta0 by sampling from its complete conditional
m0star <- ((1/sigma2[j-1])*sum(bp - beta1[j-1]*bmi) + (1/v0)*m0)/
(n/sigma2[j-1] + 1/v0)
v0star <- 1/(n/sigma2[j-1] + 1/v0)
beta0[j] <- rnorm(1, m0star, sqrt(v0star))
# update beta1 by sampling from its complete conditional
m1star <- ((1/sigma2[j-1])*sum(bmi*(bp - beta0[j])) + (1/v1)*m1)/
(sum(bmi^2)/sigma2[j-1] + 1/v1)
v1star <- 1/(sum(bmi^2)/sigma2[j-1] + 1/v1)
beta1[j] <- rnorm(1, m1star, sqrt(v1star))
# update sigma2 by sampling from its complete conditional using a metropolis step
sig2_cand <- rnorm(1, sigma2[j-1], 50)
sigma2[j] <- sigma2[j-1]
if(sig2_cand > 0){
lpcand <- sum(dnorm(bp, beta0[j] + beta1[j]*bmi, sqrt(sig2_cand), log=TRUE)) +
dinvgamma(sig2_cand, a, b, log=TRUE)
lpcurr <- sum(dnorm(bp, beta0[j] + beta1[j]*bmi, sqrt(sigma2[j-1]), log=TRUE)) +
dinvgamma(sigma2[j-1], a, b, log=TRUE)
alpha <- min(1, exp(lpcand - lpcurr))
u <- runif(1,0,1)
if(alpha > u) sigma2[j] <- sig2_cand
}
}
keep <- seq(100, J, by=100)
mean(diff(sigma2[keep]) != 0)
# check for convergence
plot(beta0[keep], type='l')
plot(beta1[keep], type='l')
plot(sigma2[keep], type='l')
plot(beta0[keep], type='l')
plot(beta1[keep], type='l')
# check for mixing
acf(beta0[keep])
acf(beta1[keep])
acf(sigma2[keep])
head(Pima.tr)
Pima.tr[type == 'No']
Pima.tr[Pima.tr$type == 'No']
Pima.trD <- filter(Pima.tr, type = 'No')
library(invgamma)
library(MASS)
library(tidyverse)
Pima.trD <- Pima.tr %>% filter(type = 'No')
Pima.trD <- Pima.tr %>% filter(type == 'No')
bmiD <- Pima.trD$bmi
bpD <- Pima.trD$bp
# prior values
m0 <- 0; v0 <- 100^2
m1 <- 0; v1 <- 100^2
a <- 1; b <- 1
# vectors to hold MCMC samples
beta0D <- beta1D <- sigma2D <- numeric()
# Initial values.  This can be pretty much anything that is reasonable,
# but I am going to use the OLS estimates as starting values
lm1D <- lm(bpD ~ bmiD)
beta0D[1] <- lm1$coefficients[1]
Pima.trD <- Pima.tr %>% filter(type == 'No')
bmiD <- Pima.trD$bmi
bpD <- Pima.trD$bp
# prior values
m0 <- 0; v0 <- 100^2
m1 <- 0; v1 <- 100^2
a <- 1; b <- 1
# vectors to hold MCMC samples
beta0D <- beta1D <- sigma2D <- numeric()
# Initial values.  This can be pretty much anything that is reasonable,
# but I am going to use the OLS estimates as starting values
lm1D <- lm(bpD ~ bmiD)
beta0D[1] <- lm1D$coefficients[1]
beta1D[1] <- lm1D$coefficients[2]
sigma2D[1] <- summary(lm1D)$sigmaD^2
# The number of MCMC iterations
JD <- 100000
nD <- length(bpD)
for(j in 2:JD){
# update beta0 by sampling from its complete conditional
m0starD <- ((1/sigma2D[j-1])*sum(bpD - beta1D[j-1]*bmiD) + (1/v0)*m0)/
(nD/sigma2D[j-1] + 1/v0)
v0starD <- 1/(nD/sigma2D[j-1] + 1/v0)
beta0D[j] <- rnorm(1, m0starD, sqrt(v0starD))
# update beta1 by sampling from its complete conditional
m1starD <- ((1/sigma2D[j-1])*sum(bmiD*(bpD - beta0D[j])) + (1/v1)*m1)/
(sum(bmiD^2)/sigma2D[j-1] + 1/v1)
v1starD <- 1/(sum(bmiD^2)/sigma2D[j-1] + 1/v1)
beta1D[j] <- rnorm(1, m1starD, sqrt(v1starD))
# update sigma2 by sampling from its complete conditional using a metropolis step
sig2_candD <- rnorm(1, sigma2D[j-1], 50)
sigma2D[j] <- sigma2D[j-1]
if(sig2_candD > 0){
lpcandD <- sum(dnorm(bpD, beta0D[j] + beta1D[j]*bmiD, sqrt(sig2_cand), log=TRUE)) +
dinvgamma(sig2_candD, a, b, log=TRUE)
lpcurrD <- sum(dnorm(bpD, beta0D[j] + beta1D[j]*bmiD, sqrt(sigma2D[j-1]), log=TRUE)) +
dinvgamma(sigma2D[j-1], a, b, log=TRUE)
alphaD <- min(1, exp(lpcandD - lpcurrD))
uD <- runif(1,0,1)
if(alphaD > uD) sigma2D[j] <- sig2_candD
}
}
sigma2D[j-1]
sigma2D[1]
Pima.trD <- Pima.tr %>% filter(type == 'No')
bmiD <- Pima.trD$bmi
bpD <- Pima.trD$bp
# prior values
m0 <- 0; v0 <- 100^2
m1 <- 0; v1 <- 100^2
a <- 1; b <- 1
# vectors to hold MCMC samples
beta0D <- beta1D <- sigma2D <- numeric()
# Initial values.  This can be pretty much anything that is reasonable,
# but I am going to use the OLS estimates as starting values
lm1D <- lm(bpD ~ bmiD)
beta0D[1] <- lm1D$coefficients[1]
beta1D[1] <- lm1D$coefficients[2]
sigma2D[1] <- summary(lm1D)$sigma^2
# The number of MCMC iterations
JD <- 100000
nD <- length(bpD)
for(j in 2:JD){
# update beta0 by sampling from its complete conditional
m0starD <- ((1/sigma2D[j-1])*sum(bpD - beta1D[j-1]*bmiD) + (1/v0)*m0)/
(nD/sigma2D[j-1] + 1/v0)
v0starD <- 1/(nD/sigma2D[j-1] + 1/v0)
beta0D[j] <- rnorm(1, m0starD, sqrt(v0starD))
# update beta1 by sampling from its complete conditional
m1starD <- ((1/sigma2D[j-1])*sum(bmiD*(bpD - beta0D[j])) + (1/v1)*m1)/
(sum(bmiD^2)/sigma2D[j-1] + 1/v1)
v1starD <- 1/(sum(bmiD^2)/sigma2D[j-1] + 1/v1)
beta1D[j] <- rnorm(1, m1starD, sqrt(v1starD))
# update sigma2 by sampling from its complete conditional using a metropolis step
sig2_candD <- rnorm(1, sigma2D[j-1], 50)
sigma2D[j] <- sigma2D[j-1]
if(sig2_candD > 0){
lpcandD <- sum(dnorm(bpD, beta0D[j] + beta1D[j]*bmiD, sqrt(sig2_cand), log=TRUE)) +
dinvgamma(sig2_candD, a, b, log=TRUE)
lpcurrD <- sum(dnorm(bpD, beta0D[j] + beta1D[j]*bmiD, sqrt(sigma2D[j-1]), log=TRUE)) +
dinvgamma(sigma2D[j-1], a, b, log=TRUE)
alphaD <- min(1, exp(lpcandD - lpcurrD))
uD <- runif(1,0,1)
if(alphaD > uD) sigma2D[j] <- sig2_candD
}
}
Pima.trD <- Pima.tr %>% filter(type == 'No')
bmiD <- Pima.trD$bmi
bpD <- Pima.trD$bp
# prior values
m0 <- 0; v0 <- 100^2
m1 <- 0; v1 <- 100^2
a <- 1; b <- 1
# vectors to hold MCMC samples
beta0D <- beta1D <- sigma2D <- numeric()
# Initial values.  This can be pretty much anything that is reasonable,
# but I am going to use the OLS estimates as starting values
lm1D <- lm(bpD ~ bmiD)
beta0D[1] <- lm1D$coefficients[1]
beta1D[1] <- lm1D$coefficients[2]
sigma2D[1] <- summary(lm1D)$sigma^2
# The number of MCMC iterations
JD <- 100000
nD <- length(bpD)
for(j in 2:JD){
# update beta0 by sampling from its complete conditional
m0starD <- ((1/sigma2D[j-1])*sum(bpD - beta1D[j-1]*bmiD) + (1/v0)*m0)/
(nD/sigma2D[j-1] + 1/v0)
v0starD <- 1/(nD/sigma2D[j-1] + 1/v0)
beta0D[j] <- rnorm(1, m0starD, sqrt(v0starD))
# update beta1 by sampling from its complete conditional
m1starD <- ((1/sigma2D[j-1])*sum(bmiD*(bpD - beta0D[j])) + (1/v1)*m1)/
(sum(bmiD^2)/sigma2D[j-1] + 1/v1)
v1starD <- 1/(sum(bmiD^2)/sigma2D[j-1] + 1/v1)
beta1D[j] <- rnorm(1, m1starD, sqrt(v1starD))
# update sigma2 by sampling from its complete conditional using a metropolis step
sig2_candD <- rnorm(1, sigma2D[j-1], 50)
sigma2D[j] <- sigma2D[j-1]
if(sig2_candD > 0){
lpcandD <- sum(dnorm(bpD, beta0D[j] + beta1D[j]*bmiD, sqrt(sig2_candD), log=TRUE)) +
dinvgamma(sig2_candD, a, b, log=TRUE)
lpcurrD <- sum(dnorm(bpD, beta0D[j] + beta1D[j]*bmiD, sqrt(sigma2D[j-1]), log=TRUE)) +
dinvgamma(sigma2D[j-1], a, b, log=TRUE)
alphaD <- min(1, exp(lpcandD - lpcurrD))
uD <- runif(1,0,1)
if(alphaD > uD) sigma2D[j] <- sig2_candD
}
}
keepD <- seq(100, JD, by=100)
par(mfrow=c(3,2))
# check for convergence
plot(beta0D[keepD], type='l')
plot(beta1D[keepD], type='l')
plot(sigma2D[keepD], type='l')
# check for mixing
acf(beta0D[keepD])
acf(beta1D[keepD])
acf(sigma2D[keepD])
Pima.trH <- filter(Pima.tr, type == 'Yes')
bmi <- Pima.trH$bmi
bp <- Pima.trH$bp
# vectors to hold MCMC samples
beta0 <- beta1 <- sigma2 <- numeric()
# Initial values.  This can be pretty much anything that is reasonable,
# but I am going to use the OLS estimates as starting values
lm1 <- lm(bp ~ bmi)
beta0[1] <- lm1$coefficients[1]
beta1[1] <- lm1$coefficients[2]
sigma2[1] <- summary(lm1)$sigma^2
# The number of MCMC iterations
J <- 100000
n <- length(bp)
for(j in 2:J){
# update beta0 by sampling from its complete conditional
m0star <- ((1/sigma2[j-1])*sum(bp - beta1[j-1]*bmi) + (1/v0)*m0)/
(n/sigma2[j-1] + 1/v0)
v0star <- 1/(n/sigma2[j-1] + 1/v0)
beta0[j] <- rnorm(1, m0star, sqrt(v0star))
# update beta1 by sampling from its complete conditional
m1star <- ((1/sigma2[j-1])*sum(bmi*(bp - beta0[j])) + (1/v1)*m1)/
(sum(bmi^2)/sigma2[j-1] + 1/v1)
v1star <- 1/(sum(bmi^2)/sigma2[j-1] + 1/v1)
beta1[j] <- rnorm(1, m1star, sqrt(v1star))
# update sigma2 by sampling from its complete conditional using a metropolis step
sig2_cand <- rnorm(1, sigma2[j-1], 50)
sigma2[j] <- sigma2[j-1]
if(sig2_cand > 0){
lpcand <- sum(dnorm(bp, beta0[j] + beta1[j]*bmi, sqrt(sig2_cand), log=TRUE)) +
dinvgamma(sig2_cand, a, b, log=TRUE)
lpcurr <- sum(dnorm(bp, beta0[j] + beta1[j]*bmi, sqrt(sigma2[j-1]), log=TRUE)) +
dinvgamma(sigma2[j-1], a, b, log=TRUE)
alpha <- min(1, exp(lpcand - lpcurr))
u <- runif(1,0,1)
if(alpha > u) sigma2[j] <- sig2_cand
}
}
keep <- seq(100, J, by=100)
par(mfrow=c(3,2))
# check for convergence
plot(beta0[keep], type='l')
plot(beta1[keep], type='l')
plot(sigma2[keep], type='l')
# check for mixing
acf(beta0[keep])
acf(beta1[keep])
acf(sigma2[keep])
quantile(beta1, c(0.025, 0.975))
quantile(beta1 - beta1D, c(0.025, 0.975))
J <- 100000
treatmentPost <- nnig.mcmc(data=tmt,m=mt,v=vt,a=at,b=bt,J=J)
nnig.mcmc <- function(data,m,v,a,b,J){
ybar <- mean(data)
s2 <- var(data)
n <- length(data)
# create empty vectors to store draws
mu <- numeric()
sigma2 <- numeric()
# initial values
mu[1] <- ybar
sigma2[1] <- s2
for(j in 2:J){
# update mu
mstar <- (n*ybar*v + m*sigma2[j-1])/(n*v + sigma2[j-1])
vstar	<- (v*sigma2[j-1])/(n*v + sigma2[j-1])
mu[j] <- rnorm(1, mstar, sqrt(vstar))
# update sigma2
astar <- a + 0.5*n
bstar <- b + 0.5*sum((data - mu[j])^2)
sigma2[j] <- rinvgamma(1, astar, bstar)
}
out <- cbind(mu, sigma2)
colnames(out) <- c("mu", "sigma2")
out
}
control <- c(35.25,43.21, 47.63, 48.99, 32.34, 34.69, 34.39,
36.58, 33.85, 32.26, 36.71, 35.01, 38.42, 39.98, 40.04)
tmt <- c(35.40, 44.79, 51.10, 50.66, 31.25, 38.80, 39.65, 38.49,
34.97, 32.24, 34.18, 33.46, 44.45, 42.86, 39.11)
mt <- 40
vt <- 10^2
mc <- 35
vc <- 10^2
at <- 1
bt <- 1
ac <- 1
bc <- 1
# Check convergence for Treatment Group
plot(treatmentPost[keep,1], type='l', xlab = 'Treatment Mu')
J <- 100000
treatmentPost <- nnig.mcmc(data=tmt,m=mt,v=vt,a=at,b=bt,J=J)
treatmentPost <- nnig.mcmc(data=tmt,m=mt,v=vt,a=at,b=bt,J=J)
controlPost <- nnig.mcmc(data=control,m=mc,v=vc,a=ac,b=bc,J=J)
# thinning
keep <- seq(11, J, length = 10000)
# thinning
keep <- seq(11, J, length = 10000)
par(mfrow=c(2,2))
# Check convergence for Treatment Group
plot(treatmentPost[keep,1], type='l', xlab = 'Treatment Mu')
# Check convergence for Treatment Group
plot(treatmentPost[keep,1], type='l', main = 'Treatment Mu')
# Check convergence for Treatment Group
plot(treatmentPost[keep,1], type='l', main = 'Treatment Mu')
plot(treatmentPost[keep,2], type='l', ylab = 'Treatment Sigma^2')
## Read in the Data
bike <- vroom("./train.csv")
install.packages(vroom)
install.packages("vroom")
## libraries
library(tidyverse)
## libraries
library(tidyverse)
library(vroom)
## Read in the Data
bike <- vroom("./train.csv")
## Read in the Data
bike <- vroom("./train.csv")
library(tidyverse)
library(vroom)
## Read in the Data
bike <- vroom("./train.csv")
getwd()
setwd("C:/Users/olivi/OneDrive/Documents/School2023/KaggleBikeShare")
getwd()
##
## Bike Share EDA Code
##
## libraries
library(tidyverse)
library(vroom)
## Read in the Data
bike <- vroom("./train.csv")
## libraries
library(tidyverse)
bike
